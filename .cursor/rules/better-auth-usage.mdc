---
description: Common patterns for using Better Auth with Convex and TanStack Start
globs: **/*.ts,**/*.tsx
created: 2025-11-08
updated: 2025-11-09
---

# Better Auth Usage Patterns (Convex + TanStack Start)

## Quick Reference

### Get Current User in Convex (Required Authentication)

```typescript
import { authComponent } from "./auth";

// authComponent.getAuthUser() THROWS an error if not authenticated
// For required authentication, let it throw or catch to customize error
const user = await authComponent.getAuthUser(ctx);
// user is guaranteed to be non-null here
```

### Get Current User in Convex (Optional Authentication)

```typescript
import { authComponent } from "./auth";

// For optional auth, wrap in try-catch since it throws when unauthenticated
let user;
try {
  user = await authComponent.getAuthUser(ctx);
} catch (error) {
  // User is not authenticated, user will be undefined
  user = null;
}
// Now user is either the authenticated user or null
```

### Use Auth in React Component

```typescript
import { useSession } from "@convex-dev/better-auth/react";

const { data: session } = useSession();
```

### Sign In/Out Client-Side

```typescript
import { authClient } from "@/lib/auth-clients";

await authClient.signIn.email({ email, password });
await authClient.signOut();
```

## Protecting Convex Functions

### Protected Query Example

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const getMyProfile = query({
  args: {},
  returns: v.object({
    id: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
  }),
  handler: async (ctx) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Not authenticated");
    }

    // User is authenticated, fetch their profile
    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user_id", (q) => q.eq("userId", user.id))
      .unique();

    return {
      id: user.id,
      email: user.email,
      name: profile?.name,
    };
  },
});
```

### Protected Mutation Example

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const createPost = mutation({
  args: {
    title: v.string(),
    content: v.string(),
  },
  returns: v.id("posts"),
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Unauthorized: Must be logged in to create posts");
    }

    return await ctx.db.insert("posts", {
      title: args.title,
      content: args.content,
      authorId: user.id,
      createdAt: Date.now(),
    });
  },
});
```

### Optional Authentication (Public + Personalized)

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const getPosts = query({
  args: {
    limit: v.optional(v.number()),
  },
  returns: v.array(
    v.object({
      _id: v.id("posts"),
      title: v.string(),
      content: v.string(),
      isMyPost: v.boolean(),
    })
  ),
  handler: async (ctx, args) => {
    // IMPORTANT: authComponent.getAuthUser() throws if not authenticated
    // For optional auth, wrap in try-catch
    let user;
    try {
      user = await authComponent.getAuthUser(ctx);
    } catch (error) {
      // User is not authenticated
      user = null;
    }

    const posts = await ctx.db
      .query("posts")
      .order("desc")
      .take(args.limit ?? 10);

    // Add personalization if user is logged in
    return posts.map((post) => ({
      ...post,
      isMyPost: user ? post.authorId === user.id : false,
    }));
  },
});
```

### Role-Based Authorization

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const deleteUser = mutation({
  args: {
    userId: v.id("users"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Not authenticated");
    }

    // Check if user has admin role
    const userDoc = await ctx.db.get(user.id);
    if (userDoc?.role !== "admin") {
      throw new Error("Forbidden: Admin access required");
    }

    await ctx.db.delete(args.userId);
    return null;
  },
});
```

## React Component Patterns

### Using Session Hook

```typescript
import { useSession } from "@convex-dev/better-auth/react";

function UserProfile() {
  const { data: session, isPending } = useSession();

  if (isPending) {
    return <div>Loading...</div>;
  }

  if (!session) {
    return <div>Not logged in</div>;
  }

  return (
    <div>
      <h1>Welcome, {session.user.email}</h1>
      <p>User ID: {session.user.id}</p>
    </div>
  );
}
```

### Sign In Form

```typescript
import { authClient } from "@/lib/auth-clients";
import { useState } from "react";

function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    const { data, error } = await authClient.signIn.email({
      email,
      password,
    });

    if (error) {
      setError(error.message || "Sign in failed");
      return;
    }

    // Successfully signed in, data contains user and session
    console.log("Signed in:", data);
  };

  return (
    <form onSubmit={handleSignIn}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      {error && <div className="error">{error}</div>}
      <button type="submit">Sign In</button>
    </form>
  );
}
```

### Sign Up Form

```typescript
import { authClient } from "@/lib/auth-clients";
import { useState } from "react";

function SignUpForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();

    const { data, error } = await authClient.signUp.email({
      email,
      password,
      name,
    });

    if (error) {
      console.error("Sign up failed:", error);
      return;
    }

    console.log("Signed up:", data);
  };

  return (
    <form onSubmit={handleSignUp}>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
        required
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      <button type="submit">Sign Up</button>
    </form>
  );
}
```

### Sign Out Button

```typescript
import { authClient } from "@/lib/auth-clients";

function SignOutButton() {
  const handleSignOut = async () => {
    await authClient.signOut();
    // User is now signed out, session will be cleared
  };

  return <button onClick={handleSignOut}>Sign Out</button>;
}
```

### Protected Route Component

```typescript
import { useSession } from "@convex-dev/better-auth/react";
import { Navigate } from "@tanstack/react-router";

function ProtectedPage({ children }: { children: React.ReactNode }) {
  const { data: session, isPending } = useSession();

  if (isPending) {
    return <div>Loading...</div>;
  }

  if (!session) {
    return <Navigate to="/login" />;
  }

  return <>{children}</>;
}
```

## TanStack Start Server-Side Patterns

### Server-Side Setup

First, set up the server-side fetch helpers in `src/lib/auth-server.ts`:

```typescript
import { createAuth } from "convex/auth";
import { setupFetchClient } from "@convex-dev/better-auth/react-start";
import { getCookie } from "@tanstack/react-start/server";

export const { fetchQuery, fetchMutation, fetchAction } =
  await setupFetchClient(createAuth, getCookie);
```

### Auth Check in Server Functions

Use this pattern to check authentication in TanStack Start server functions:

```typescript
import { createServerFn } from "@tanstack/react-start";
import { fetchQuery } from "@/lib/auth-server";
import { api } from "../../../convex/_generated/api";

// Server function to check authentication
const checkAuth = createServerFn({ method: "GET" }).handler(async () => {
  const user = await fetchQuery(api.auth.getCurrentUser, {});
  const isAuthenticated = !!user;
  const userId = user?.userId || user?._id;
  return { isAuthenticated, userId };
});
```

### Protected Route Guards

Use in `beforeLoad` for instant redirects:

```typescript
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/(authenticated)/_layout")({
  ssr: true, // Enable SSR for server-side auth checks
  beforeLoad: async ({ location }) => {
    const { isAuthenticated, userId } = await checkAuth();

    if (!isAuthenticated) {
      throw redirect({
        to: "/login",
        search: {
          redirect: location.href,
        },
      });
    }

    return { userId };
  },
  component: AuthenticatedLayout,
});
```

### Why This Pattern?

✅ **Proper Integration**: Uses the official Better Auth + Convex pattern  
✅ **Single Source of Truth**: Authentication state managed by Convex  
✅ **SSR Compatible**: Works with TanStack Start server functions  
✅ **Automatic Cookies**: Cookies passed automatically via `getCookie`  
✅ **Type Safe**: Full TypeScript support with inferred types

### Server Function Examples

**Update user data:**

```typescript
// convex/users.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const updateProfile = mutation({
  args: {
    name: v.string(),
  },
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);
    if (!user) throw new Error("Not authenticated");

    // Update user profile
    await ctx.db.patch(user._id, { name: args.name });
  },
});

// src/routes/profile.ts
import { createServerFn } from "@tanstack/react-start";
import { fetchMutation } from "@/lib/auth-server";
import { api } from "../../convex/_generated/api";

export const updateProfileFn = createServerFn({ method: "POST" }).handler(
  async ({ data }) => {
    await fetchMutation(api.users.updateProfile, {
      name: data.name,
    });
  }
);
```

**Fetch authenticated data:**

```typescript
// convex/users.ts
import { query } from "./_generated/server";
import { authComponent } from "./auth";

export const getMyData = query({
  args: {},
  handler: async (ctx) => {
    const user = await authComponent.getAuthUser(ctx);
    if (!user) throw new Error("Not authenticated");

    return {
      user,
      profile: await ctx.db
        .query("profiles")
        .withIndex("by_userId", (q) => q.eq("userId", user._id))
        .unique(),
    };
  },
});

// src/routes/dashboard.tsx
import { createServerFn } from "@tanstack/react-start";
import { fetchQuery } from "@/lib/auth-server";
import { api } from "../../convex/_generated/api";

const loadDashboardData = createServerFn({ method: "GET" }).handler(
  async () => {
    return await fetchQuery(api.users.getMyData, {});
  }
);
```

## Common Auth Methods

### authClient Methods (Client-Side)

```typescript
import { authClient } from "@/lib/auth-clients";

// Sign in with email/password
await authClient.signIn.email({ email, password });

// Sign up with email/password
await authClient.signUp.email({ email, password, name });

// Sign out
await authClient.signOut();

// Get current session (use useSession hook instead in components)
const session = await authClient.getSession();
```

### authComponent Methods (Convex Functions)

```typescript
import { authComponent } from "./auth";

// IMPORTANT: authComponent.getAuthUser() THROWS an error if not authenticated
// It does NOT return null - you must wrap in try-catch for optional auth

// For required authentication (let it throw):
const user = await authComponent.getAuthUser(ctx);

// For optional authentication (wrap in try-catch):
let user;
try {
  user = await authComponent.getAuthUser(ctx);
} catch (error) {
  user = null; // Not authenticated
}

// User object structure when authenticated:
// {
//   _id: Id<"user">;
//   userId?: string | null;
//   email: string;
//   name: string;
//   emailVerified: boolean;
//   image?: string | null;
//   createdAt: number;
//   updatedAt: number;
// }
```

### Server-Side Fetch Methods (TanStack Start)

```typescript
import { fetchQuery, fetchMutation, fetchAction } from "@/lib/auth-server";
import { api } from "../../convex/_generated/api";

// Fetch data from Convex query (with auth)
const data = await fetchQuery(api.myModule.myQuery, { arg: "value" });

// Call Convex mutation (with auth)
await fetchMutation(api.myModule.myMutation, { arg: "value" });

// Call Convex action (with auth)
await fetchAction(api.myModule.myAction, { arg: "value" });
```

## Best Practices

1. **Understand Authentication Error Behavior**:

   - **CRITICAL**: `authComponent.getAuthUser(ctx)` THROWS an error when not authenticated
   - It does NOT return `null` - you cannot check `if (!user)`
   - **For required auth**: Let it throw or catch to customize the error message
   - **For optional auth**: Always wrap in try-catch to handle unauthenticated users

   ```typescript
   // ❌ WRONG - this won't work for optional auth
   const user = await authComponent.getAuthUser(ctx);
   if (!user) {
     // This code will never run - an error is thrown instead
   }

   // ✅ CORRECT - for optional authentication
   let user;
   try {
     user = await authComponent.getAuthUser(ctx);
   } catch (error) {
     user = null; // Handle unauthenticated case
   }

   // ✅ CORRECT - for required authentication (let it throw)
   const user = await authComponent.getAuthUser(ctx);
   // If we get here, user is guaranteed to be authenticated
   ```

2. **Always Check Authentication in Protected Functions**:

   - **Convex Functions**: Use `authComponent.getAuthUser(ctx)` in every protected function
   - **TanStack Start Server Functions**: Use `fetchQuery(api.auth.getCurrentUser, {})` pattern
   - Let the error throw for required auth, or catch to customize the message

3. **Provide Clear Error Messages (Optional)**:

   ```typescript
   // You can catch and rethrow with a custom message
   try {
     const user = await authComponent.getAuthUser(ctx);
     // ... use user
   } catch (error) {
     throw new Error("Unauthorized: Please sign in to access this resource");
   }
   ```

4. **Use Type Safety**:

   ```typescript
   // User is guaranteed to exist after successful getAuthUser call
   const user = await authComponent.getAuthUser(ctx);
   // TypeScript knows user is non-null here (if no error was thrown)
   const userId: string = user.id;
   ```

5. **Handle Loading States**:

   ```typescript
   const { data: session, isPending } = useSession();

   if (isPending) {
     return <LoadingSpinner />;
   }
   ```

6. **Separate Public and Private Data**:

   - Create separate queries for public vs authenticated views
   - Don't expose sensitive data in public queries
   - Filter data based on user permissions

7. **Use Proper Server-Side Pattern**:
   - **DO**: Use `fetchQuery/fetchMutation/fetchAction` from `@/lib/auth-server` in TanStack Start server functions
   - **DON'T**: Call `fetchSession` directly - it bypasses the Convex integration
   - Enable SSR (`ssr: true`) on protected routes for instant server-side auth checks
   - Use `beforeLoad` with `throw redirect()` for instant redirects (no component flash)

## Troubleshooting

### "Unauthenticated" errors in Convex functions

**Problem**: Getting "Uncaught Error: Unauthenticated" when calling a query/mutation

**Common Causes**:

1. **Missing try-catch for optional auth**: If your function should work for both authenticated and unauthenticated users, wrap `authComponent.getAuthUser(ctx)` in try-catch:

   ```typescript
   // ✅ CORRECT
   let user;
   try {
     user = await authComponent.getAuthUser(ctx);
   } catch (error) {
     user = null; // Gracefully handle unauthenticated case
   }
   ```

2. **Authentication not set up on client**:
   - Ensure `ConvexBetterAuthProvider` wraps your app
   - Check that `setAuth(token)` is called in `beforeLoad` (see setup rules)
   - Verify session exists with `useSession()` hook

### Session not persisting

- Sessions are stored in HTTP-only cookies automatically
- Check that your `SITE_URL` environment variable is correct
- Ensure cookies are enabled in the browser

### TypeScript errors with user object

- User object type is inferred from Better Auth
- Use optional chaining for optional fields: `user.name ?? "Anonymous"`

---

_Last updated: 2025-11-09 (Updated with critical auth error behavior - getAuthUser throws instead of returning null)_
