---
description: Common patterns for using Better Auth with Convex and TanStack Start
globs: **/*.ts,**/*.tsx
created: 2025-11-08
---

# Better Auth Usage Patterns (Convex + TanStack Start)

## Quick Reference

### Get Current User in Convex

```typescript
import { authComponent } from "./auth";

const user = await authComponent.getAuthUser(ctx);
if (!user) {
  throw new Error("Not authenticated");
}
```

### Use Auth in React Component

```typescript
import { useSession } from "@convex-dev/better-auth/react";

const { data: session } = useSession();
```

### Sign In/Out Client-Side

```typescript
import { authClient } from "@/lib/auth-clients";

await authClient.signIn.email({ email, password });
await authClient.signOut();
```

## Protecting Convex Functions

### Protected Query Example

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const getMyProfile = query({
  args: {},
  returns: v.object({
    id: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
  }),
  handler: async (ctx) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Not authenticated");
    }

    // User is authenticated, fetch their profile
    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user_id", (q) => q.eq("userId", user.id))
      .unique();

    return {
      id: user.id,
      email: user.email,
      name: profile?.name,
    };
  },
});
```

### Protected Mutation Example

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const createPost = mutation({
  args: {
    title: v.string(),
    content: v.string(),
  },
  returns: v.id("posts"),
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Unauthorized: Must be logged in to create posts");
    }

    return await ctx.db.insert("posts", {
      title: args.title,
      content: args.content,
      authorId: user.id,
      createdAt: Date.now(),
    });
  },
});
```

### Optional Authentication (Public + Personalized)

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const getPosts = query({
  args: {
    limit: v.optional(v.number()),
  },
  returns: v.array(
    v.object({
      _id: v.id("posts"),
      title: v.string(),
      content: v.string(),
      isMyPost: v.boolean(),
    })
  ),
  handler: async (ctx, args) => {
    // Get user if authenticated, null otherwise
    const user = await authComponent.getAuthUser(ctx);

    const posts = await ctx.db
      .query("posts")
      .order("desc")
      .take(args.limit ?? 10);

    // Add personalization if user is logged in
    return posts.map((post) => ({
      ...post,
      isMyPost: user ? post.authorId === user.id : false,
    }));
  },
});
```

### Role-Based Authorization

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const deleteUser = mutation({
  args: {
    userId: v.id("users"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Not authenticated");
    }

    // Check if user has admin role
    const userDoc = await ctx.db.get(user.id);
    if (userDoc?.role !== "admin") {
      throw new Error("Forbidden: Admin access required");
    }

    await ctx.db.delete(args.userId);
    return null;
  },
});
```

## React Component Patterns

### Using Session Hook

```typescript
import { useSession } from "@convex-dev/better-auth/react";

function UserProfile() {
  const { data: session, isPending } = useSession();

  if (isPending) {
    return <div>Loading...</div>;
  }

  if (!session) {
    return <div>Not logged in</div>;
  }

  return (
    <div>
      <h1>Welcome, {session.user.email}</h1>
      <p>User ID: {session.user.id}</p>
    </div>
  );
}
```

### Sign In Form

```typescript
import { authClient } from "@/lib/auth-clients";
import { useState } from "react";

function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    const { data, error } = await authClient.signIn.email({
      email,
      password,
    });

    if (error) {
      setError(error.message || "Sign in failed");
      return;
    }

    // Successfully signed in, data contains user and session
    console.log("Signed in:", data);
  };

  return (
    <form onSubmit={handleSignIn}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      {error && <div className="error">{error}</div>}
      <button type="submit">Sign In</button>
    </form>
  );
}
```

### Sign Up Form

```typescript
import { authClient } from "@/lib/auth-clients";
import { useState } from "react";

function SignUpForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();

    const { data, error } = await authClient.signUp.email({
      email,
      password,
      name,
    });

    if (error) {
      console.error("Sign up failed:", error);
      return;
    }

    console.log("Signed up:", data);
  };

  return (
    <form onSubmit={handleSignUp}>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
        required
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      <button type="submit">Sign Up</button>
    </form>
  );
}
```

### Sign Out Button

```typescript
import { authClient } from "@/lib/auth-clients";

function SignOutButton() {
  const handleSignOut = async () => {
    await authClient.signOut();
    // User is now signed out, session will be cleared
  };

  return <button onClick={handleSignOut}>Sign Out</button>;
}
```

### Protected Route Component

```typescript
import { useSession } from "@convex-dev/better-auth/react";
import { Navigate } from "@tanstack/react-router";

function ProtectedPage({ children }: { children: React.ReactNode }) {
  const { data: session, isPending } = useSession();

  if (isPending) {
    return <div>Loading...</div>;
  }

  if (!session) {
    return <Navigate to="/login" />;
  }

  return <>{children}</>;
}
```

## Common Auth Methods

### authClient Methods (Client-Side)

```typescript
import { authClient } from "@/lib/auth-clients";

// Sign in with email/password
await authClient.signIn.email({ email, password });

// Sign up with email/password
await authClient.signUp.email({ email, password, name });

// Sign out
await authClient.signOut();

// Get current session (use useSession hook instead in components)
const session = await authClient.getSession();
```

### authComponent Methods (Convex Functions)

```typescript
import { authComponent } from "./auth";

// Get authenticated user (returns null if not authenticated)
const user = await authComponent.getAuthUser(ctx);

// User object structure:
// {
//   id: string;
//   email: string;
//   name?: string;
//   emailVerified: boolean;
//   image?: string;
//   createdAt: Date;
//   updatedAt: Date;
// }
```

## Best Practices

1. **Always Check Authentication**:

   - Use `authComponent.getAuthUser(ctx)` in every protected function
   - Throw descriptive errors when authentication fails
   - Consider whether null user is allowed (public data with personalization)

2. **Provide Clear Error Messages**:

   ```typescript
   if (!user) {
     throw new Error("Unauthorized: Please sign in to access this resource");
   }
   ```

3. **Use Type Safety**:

   ```typescript
   // User is guaranteed to exist after this check
   const user = await authComponent.getAuthUser(ctx);
   if (!user) throw new Error("Not authenticated");

   // TypeScript knows user is non-null here
   const userId: string = user.id;
   ```

4. **Handle Loading States**:

   ```typescript
   const { data: session, isPending } = useSession();

   if (isPending) {
     return <LoadingSpinner />;
   }
   ```

5. **Separate Public and Private Data**:
   - Create separate queries for public vs authenticated views
   - Don't expose sensitive data in public queries
   - Filter data based on user permissions

## Troubleshooting

### "Not authenticated" errors in Convex functions

- Ensure `ConvexBetterAuthProvider` wraps your app
- Check that `setAuth(token)` is called in `beforeLoad` (see setup rules)
- Verify session exists with `useSession()` hook

### Session not persisting

- Sessions are stored in HTTP-only cookies automatically
- Check that your `SITE_URL` environment variable is correct
- Ensure cookies are enabled in the browser

### TypeScript errors with user object

- User object type is inferred from Better Auth
- Use optional chaining for optional fields: `user.name ?? "Anonymous"`

---

_Last updated: 2025-11-08_
