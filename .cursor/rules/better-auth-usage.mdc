---
description: Common patterns for using Better Auth with Convex and TanStack Start
globs: **/*.ts,**/*.tsx
created: 2025-11-08
---

# Better Auth Usage Patterns (Convex + TanStack Start)

## Quick Reference

### Get Current User in Convex

```typescript
import { authComponent } from "./auth";

const user = await authComponent.getAuthUser(ctx);
if (!user) {
  throw new Error("Not authenticated");
}
```

### Use Auth in React Component

```typescript
import { useSession } from "@convex-dev/better-auth/react";

const { data: session } = useSession();
```

### Sign In/Out Client-Side

```typescript
import { authClient } from "@/lib/auth-clients";

await authClient.signIn.email({ email, password });
await authClient.signOut();
```

## Protecting Convex Functions

### Protected Query Example

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const getMyProfile = query({
  args: {},
  returns: v.object({
    id: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
  }),
  handler: async (ctx) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Not authenticated");
    }

    // User is authenticated, fetch their profile
    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user_id", (q) => q.eq("userId", user.id))
      .unique();

    return {
      id: user.id,
      email: user.email,
      name: profile?.name,
    };
  },
});
```

### Protected Mutation Example

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const createPost = mutation({
  args: {
    title: v.string(),
    content: v.string(),
  },
  returns: v.id("posts"),
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Unauthorized: Must be logged in to create posts");
    }

    return await ctx.db.insert("posts", {
      title: args.title,
      content: args.content,
      authorId: user.id,
      createdAt: Date.now(),
    });
  },
});
```

### Optional Authentication (Public + Personalized)

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const getPosts = query({
  args: {
    limit: v.optional(v.number()),
  },
  returns: v.array(
    v.object({
      _id: v.id("posts"),
      title: v.string(),
      content: v.string(),
      isMyPost: v.boolean(),
    })
  ),
  handler: async (ctx, args) => {
    // Get user if authenticated, null otherwise
    const user = await authComponent.getAuthUser(ctx);

    const posts = await ctx.db
      .query("posts")
      .order("desc")
      .take(args.limit ?? 10);

    // Add personalization if user is logged in
    return posts.map((post) => ({
      ...post,
      isMyPost: user ? post.authorId === user.id : false,
    }));
  },
});
```

### Role-Based Authorization

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const deleteUser = mutation({
  args: {
    userId: v.id("users"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);

    if (!user) {
      throw new Error("Not authenticated");
    }

    // Check if user has admin role
    const userDoc = await ctx.db.get(user.id);
    if (userDoc?.role !== "admin") {
      throw new Error("Forbidden: Admin access required");
    }

    await ctx.db.delete(args.userId);
    return null;
  },
});
```

## React Component Patterns

### Using Session Hook

```typescript
import { useSession } from "@convex-dev/better-auth/react";

function UserProfile() {
  const { data: session, isPending } = useSession();

  if (isPending) {
    return <div>Loading...</div>;
  }

  if (!session) {
    return <div>Not logged in</div>;
  }

  return (
    <div>
      <h1>Welcome, {session.user.email}</h1>
      <p>User ID: {session.user.id}</p>
    </div>
  );
}
```

### Sign In Form

```typescript
import { authClient } from "@/lib/auth-clients";
import { useState } from "react";

function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    const { data, error } = await authClient.signIn.email({
      email,
      password,
    });

    if (error) {
      setError(error.message || "Sign in failed");
      return;
    }

    // Successfully signed in, data contains user and session
    console.log("Signed in:", data);
  };

  return (
    <form onSubmit={handleSignIn}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      {error && <div className="error">{error}</div>}
      <button type="submit">Sign In</button>
    </form>
  );
}
```

### Sign Up Form

```typescript
import { authClient } from "@/lib/auth-clients";
import { useState } from "react";

function SignUpForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();

    const { data, error } = await authClient.signUp.email({
      email,
      password,
      name,
    });

    if (error) {
      console.error("Sign up failed:", error);
      return;
    }

    console.log("Signed up:", data);
  };

  return (
    <form onSubmit={handleSignUp}>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
        required
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      <button type="submit">Sign Up</button>
    </form>
  );
}
```

### Sign Out Button

```typescript
import { authClient } from "@/lib/auth-clients";

function SignOutButton() {
  const handleSignOut = async () => {
    await authClient.signOut();
    // User is now signed out, session will be cleared
  };

  return <button onClick={handleSignOut}>Sign Out</button>;
}
```

### Protected Route Component

```typescript
import { useSession } from "@convex-dev/better-auth/react";
import { Navigate } from "@tanstack/react-router";

function ProtectedPage({ children }: { children: React.ReactNode }) {
  const { data: session, isPending } = useSession();

  if (isPending) {
    return <div>Loading...</div>;
  }

  if (!session) {
    return <Navigate to="/login" />;
  }

  return <>{children}</>;
}
```

## TanStack Start Server-Side Patterns

### Server-Side Setup

First, set up the server-side fetch helpers in `src/lib/auth-server.ts`:

```typescript
import { createAuth } from "convex/auth";
import { setupFetchClient } from "@convex-dev/better-auth/react-start";
import { getCookie } from "@tanstack/react-start/server";

export const { fetchQuery, fetchMutation, fetchAction } =
  await setupFetchClient(createAuth, getCookie);
```

### Auth Check in Server Functions

Use this pattern to check authentication in TanStack Start server functions:

```typescript
import { createServerFn } from "@tanstack/react-start";
import { fetchQuery } from "@/lib/auth-server";
import { api } from "../../../convex/_generated/api";

// Server function to check authentication
const checkAuth = createServerFn({ method: "GET" }).handler(async () => {
  const user = await fetchQuery(api.auth.getCurrentUser, {});
  const isAuthenticated = !!user;
  const userId = user?.userId || user?._id;
  return { isAuthenticated, userId };
});
```

### Protected Route Guards

Use in `beforeLoad` for instant redirects:

```typescript
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/(authenticated)/_layout")({
  ssr: true, // Enable SSR for server-side auth checks
  beforeLoad: async ({ location }) => {
    const { isAuthenticated, userId } = await checkAuth();

    if (!isAuthenticated) {
      throw redirect({
        to: "/login",
        search: {
          redirect: location.href,
        },
      });
    }

    return { userId };
  },
  component: AuthenticatedLayout,
});
```

### Why This Pattern?

✅ **Proper Integration**: Uses the official Better Auth + Convex pattern  
✅ **Single Source of Truth**: Authentication state managed by Convex  
✅ **SSR Compatible**: Works with TanStack Start server functions  
✅ **Automatic Cookies**: Cookies passed automatically via `getCookie`  
✅ **Type Safe**: Full TypeScript support with inferred types

### Server Function Examples

**Update user data:**

```typescript
// convex/users.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";
import { authComponent } from "./auth";

export const updateProfile = mutation({
  args: {
    name: v.string(),
  },
  handler: async (ctx, args) => {
    const user = await authComponent.getAuthUser(ctx);
    if (!user) throw new Error("Not authenticated");

    // Update user profile
    await ctx.db.patch(user._id, { name: args.name });
  },
});

// src/routes/profile.ts
import { createServerFn } from "@tanstack/react-start";
import { fetchMutation } from "@/lib/auth-server";
import { api } from "../../convex/_generated/api";

export const updateProfileFn = createServerFn({ method: "POST" }).handler(
  async ({ data }) => {
    await fetchMutation(api.users.updateProfile, {
      name: data.name,
    });
  }
);
```

**Fetch authenticated data:**

```typescript
// convex/users.ts
import { query } from "./_generated/server";
import { authComponent } from "./auth";

export const getMyData = query({
  args: {},
  handler: async (ctx) => {
    const user = await authComponent.getAuthUser(ctx);
    if (!user) throw new Error("Not authenticated");

    return {
      user,
      profile: await ctx.db
        .query("profiles")
        .withIndex("by_userId", (q) => q.eq("userId", user._id))
        .unique(),
    };
  },
});

// src/routes/dashboard.tsx
import { createServerFn } from "@tanstack/react-start";
import { fetchQuery } from "@/lib/auth-server";
import { api } from "../../convex/_generated/api";

const loadDashboardData = createServerFn({ method: "GET" }).handler(
  async () => {
    return await fetchQuery(api.users.getMyData, {});
  }
);
```

## Common Auth Methods

### authClient Methods (Client-Side)

```typescript
import { authClient } from "@/lib/auth-clients";

// Sign in with email/password
await authClient.signIn.email({ email, password });

// Sign up with email/password
await authClient.signUp.email({ email, password, name });

// Sign out
await authClient.signOut();

// Get current session (use useSession hook instead in components)
const session = await authClient.getSession();
```

### authComponent Methods (Convex Functions)

```typescript
import { authComponent } from "./auth";

// Get authenticated user (returns null if not authenticated)
const user = await authComponent.getAuthUser(ctx);

// User object structure:
// {
//   _id: Id<"user">;
//   userId?: string | null;
//   email: string;
//   name: string;
//   emailVerified: boolean;
//   image?: string | null;
//   createdAt: number;
//   updatedAt: number;
// }
```

### Server-Side Fetch Methods (TanStack Start)

```typescript
import { fetchQuery, fetchMutation, fetchAction } from "@/lib/auth-server";
import { api } from "../../convex/_generated/api";

// Fetch data from Convex query (with auth)
const data = await fetchQuery(api.myModule.myQuery, { arg: "value" });

// Call Convex mutation (with auth)
await fetchMutation(api.myModule.myMutation, { arg: "value" });

// Call Convex action (with auth)
await fetchAction(api.myModule.myAction, { arg: "value" });
```

## Best Practices

1. **Always Check Authentication**:

   - **Convex Functions**: Use `authComponent.getAuthUser(ctx)` in every protected function
   - **TanStack Start Server Functions**: Use `fetchQuery(api.auth.getCurrentUser, {})` pattern
   - Throw descriptive errors when authentication fails
   - Consider whether null user is allowed (public data with personalization)

2. **Provide Clear Error Messages**:

   ```typescript
   if (!user) {
     throw new Error("Unauthorized: Please sign in to access this resource");
   }
   ```

3. **Use Type Safety**:

   ```typescript
   // User is guaranteed to exist after this check
   const user = await authComponent.getAuthUser(ctx);
   if (!user) throw new Error("Not authenticated");

   // TypeScript knows user is non-null here
   const userId: string = user.id;
   ```

4. **Handle Loading States**:

   ```typescript
   const { data: session, isPending } = useSession();

   if (isPending) {
     return <LoadingSpinner />;
   }
   ```

5. **Separate Public and Private Data**:

   - Create separate queries for public vs authenticated views
   - Don't expose sensitive data in public queries
   - Filter data based on user permissions

6. **Use Proper Server-Side Pattern**:
   - **DO**: Use `fetchQuery/fetchMutation/fetchAction` from `@/lib/auth-server` in TanStack Start server functions
   - **DON'T**: Call `fetchSession` directly - it bypasses the Convex integration
   - Enable SSR (`ssr: true`) on protected routes for instant server-side auth checks
   - Use `beforeLoad` with `throw redirect()` for instant redirects (no component flash)

## Troubleshooting

### "Not authenticated" errors in Convex functions

- Ensure `ConvexBetterAuthProvider` wraps your app
- Check that `setAuth(token)` is called in `beforeLoad` (see setup rules)
- Verify session exists with `useSession()` hook

### Session not persisting

- Sessions are stored in HTTP-only cookies automatically
- Check that your `SITE_URL` environment variable is correct
- Ensure cookies are enabled in the browser

### TypeScript errors with user object

- User object type is inferred from Better Auth
- Use optional chaining for optional fields: `user.name ?? "Anonymous"`

---

_Last updated: 2025-11-09_
