# Data Fetching Optimization with Convex + TanStack Query

## The Problem

Navigation feels slow because the UI waits for all data to load before rendering. This is caused by:

1. **Blocking data fetching**: Using Convex's `useQuery` directly doesn't integrate with TanStack Router's preloading
2. **No stale-while-revalidate**: Data isn't cached between navigations
3. **No parallel loading**: Components wait for all data before rendering anything

## The Solution (Already Set Up!)

You **already have** TanStack Query + Convex integration via `ConvexQueryClient` in `src/router.tsx`. You just need to use it correctly.

### Key Benefits

‚úÖ **Automatic Preloading**: With `defaultPreload: "intent"`, data loads on hover  
‚úÖ **Instant Navigation**: Show cached data immediately, update when fresh data arrives  
‚úÖ **Reactive Updates**: Convex pushes updates automatically (no polling needed)  
‚úÖ **Parallel Loading**: Use React Suspense to load sections independently  
‚úÖ **Zero Config**: Works with your existing setup

## How It Works

### 1. Your Router Setup (Already Configured)

```typescript
// src/router.tsx
const convexQueryClient = new ConvexQueryClient(convex);

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryKeyHashFn: convexQueryClient.hashFn(),
      queryFn: convexQueryClient.queryFn(),
    },
  },
});

const router = createRouter({
  routeTree,
  defaultPreload: "intent", // ‚ö° Preloads data on hover!
  // ...
});
```

This means:
- Hovering over a link preloads that route's data
- TanStack Query caches all Convex queries
- Data is reactive (updates automatically)

### 2. Using `convexQuery` with `useSuspenseQuery`

**‚ùå Old Way (Slow)**
```typescript
import { useQuery } from "convex/react";

function Dashboard() {
  const data = useQuery(api.some.query, {});
  
  if (data === undefined) {
    return <div>Loading...</div>; // Blocks entire UI
  }
  
  return <div>{/* render */}</div>;
}
```

**‚úÖ New Way (Fast)**
```typescript
import { useSuspenseQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { Suspense } from "react";

function Dashboard() {
  return (
    <div>
      {/* Shell renders immediately */}
      <h1>Dashboard</h1>
      
      {/* Each section loads independently */}
      <Suspense fallback={<Skeleton />}>
        <DataSection />
      </Suspense>
    </div>
  );
}

function DataSection() {
  // This suspends until data is ready
  const { data } = useSuspenseQuery(
    convexQuery(api.some.query, { arg: "value" })
  );
  
  return <div>{data.something}</div>;
}
```

### 3. Key API

**`convexQuery(functionRef, args)`** - Creates query options for TanStack Query

```typescript
import { convexQuery } from "@convex-dev/react-query";
import { api } from "../convex/_generated/api";

// No arguments
const queryOptions = convexQuery(api.users.list, {});

// With arguments
const queryOptions = convexQuery(api.posts.get, { postId: "123" });

// With "skip" to conditionally enable
const queryOptions = convexQuery(
  api.users.getMe, 
  isAuthenticated ? {} : "skip"
);
```

**`useSuspenseQuery(convexQuery(...))`** - Fetch data with automatic caching

```typescript
const { data } = useSuspenseQuery(
  convexQuery(api.users.list, {})
);
// data is guaranteed to be loaded (no undefined check needed)
```

## Real-World Example

### Before: Blocking Dashboard

```typescript
function ConsumerDashboard() {
  const session = authClient.useSession();
  const progress = useQuery(api.consumer.getProgress, session ? {} : "skip");
  const transactions = useQuery(api.consumer.getTransactions, session ? {} : "skip");
  
  if (!progress || !transactions) {
    return <div>Loading...</div>; // ‚ùå Blocks everything
  }
  
  return (
    <div>
      <h1>Dashboard</h1>
      {/* UI */}
    </div>
  );
}
```

### After: Progressive Dashboard

```typescript
import { useSuspenseQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { Suspense } from "react";

function ConsumerDashboard() {
  const session = authClient.useSession();
  const firstName = session?.user?.name?.split(" ")[0] || "there";
  
  return (
    <ConsumerLayout>
      {/* ‚úÖ Shows immediately */}
      <h1>Hey {firstName},</h1>
      
      {/* ‚úÖ Loads independently with fallback */}
      <Suspense fallback={<p>Loading progress...</p>}>
        <ProgressSection />
      </Suspense>
      
      {/* ‚úÖ Loads independently in parallel */}
      <Suspense fallback={<p>Loading transactions...</p>}>
        <TransactionsSection />
      </Suspense>
    </ConsumerLayout>
  );
}

function ProgressSection() {
  const { data: progress } = useSuspenseQuery(
    convexQuery(api.consumer.getProgress, {})
  );
  
  return <ProgressCard {...progress} />;
}

function TransactionsSection() {
  const { data: transactions } = useSuspenseQuery(
    convexQuery(api.consumer.getTransactions, { limit: 5 })
  );
  
  return transactions.map(tx => <TransactionCard key={tx._id} {...tx} />);
}
```

## Navigation Flow

### Without Preloading (Old)
1. User clicks link
2. Route changes
3. Component mounts
4. Data starts fetching
5. **User sees loading spinner** ‚è≥
6. Data arrives
7. UI renders

### With Preloading (New)
1. User **hovers** over link
2. **Data starts preloading** ‚ö°
3. User clicks link
4. Route changes
5. Component mounts
6. **UI renders immediately with cached data** üöÄ
7. Fresh data arrives (if changed)
8. UI updates reactively

## Advanced Patterns

### Conditional Queries

```typescript
const { data } = useSuspenseQuery(
  convexQuery(
    api.users.getProfile,
    userId ? { userId } : "skip" // Disabled when userId is null
  )
);
```

### Mutations

For mutations, continue using Convex's `useMutation`:

```typescript
import { useMutation } from "convex/react";

function Component() {
  const updateProfile = useMutation(api.users.update);
  
  const handleSubmit = async (data) => {
    await updateProfile({ name: data.name });
  };
}
```

### Error Handling

```typescript
import { ErrorBoundary } from "react-error-boundary";

function Dashboard() {
  return (
    <ErrorBoundary fallback={<div>Error loading data</div>}>
      <Suspense fallback={<Skeleton />}>
        <DataSection />
      </Suspense>
    </ErrorBoundary>
  );
}
```

## Best Practices

### 1. **Use Suspense Boundaries Strategically**

```typescript
// ‚úÖ Good: Granular loading states
<div>
  <Suspense fallback={<HeaderSkeleton />}>
    <Header />
  </Suspense>
  <Suspense fallback={<ContentSkeleton />}>
    <Content />
  </Suspense>
</div>

// ‚ùå Bad: One boundary blocks everything
<Suspense fallback={<FullPageSkeleton />}>
  <Header />
  <Content />
</Suspense>
```

### 2. **Show Meaningful Fallbacks**

```typescript
// ‚úÖ Good: Context-aware fallback
<Suspense fallback={<ProgressCardSkeleton />}>
  <ProgressCard />
</Suspense>

// ‚ùå Bad: Generic spinner
<Suspense fallback={<div>Loading...</div>}>
  <ProgressCard />
</Suspense>
```

### 3. **Leverage Automatic Preloading**

```typescript
// Your router already has this configured!
const router = createRouter({
  defaultPreload: "intent", // Preloads on hover
});

// No extra code needed - just hover links to preload
<Link to="/dashboard">Dashboard</Link>
```

### 4. **Keep Using Convex Mutations**

```typescript
// ‚úÖ Mutations work as before
const updateUser = useMutation(api.users.update);

// ‚úÖ Queries automatically update after mutations
// (Convex handles invalidation via reactive subscriptions)
```

## Migration Checklist

For each route that feels slow:

- [ ] Replace `useQuery` from `convex/react` with `useSuspenseQuery` from `@tanstack/react-query`
- [ ] Wrap query with `convexQuery(api.module.function, args)`
- [ ] Add `Suspense` boundaries around data-dependent sections
- [ ] Add meaningful fallback UI for loading states
- [ ] Remove manual `if (data === undefined)` loading checks
- [ ] Test navigation by hovering links (should preload)

## Why This Works

1. **Convex Reactivity**: Data updates are pushed from server (no polling)
2. **TanStack Query Caching**: Data is cached between navigations
3. **Suspense**: UI renders progressively as data arrives
4. **Preloading**: Router fetches data before navigation
5. **Zero Stale Data**: `staleTime: Infinity` because Convex pushes updates

## Common Pitfalls

### ‚ùå Forgetting to Import `convexQuery`

```typescript
// Wrong
const { data } = useSuspenseQuery({ queryKey: api.users.list });

// Right
const { data } = useSuspenseQuery(convexQuery(api.users.list, {}));
```

### ‚ùå Using `useQuery` Instead of `useSuspenseQuery`

```typescript
// Wrong - doesn't work with Suspense
const { data } = useQuery(convexQuery(api.users.list, {}));

// Right
const { data } = useSuspenseQuery(convexQuery(api.users.list, {}));
```

### ‚ùå Not Adding Suspense Boundaries

```typescript
// Wrong - will error without Suspense
function Component() {
  const { data } = useSuspenseQuery(convexQuery(api.users.list, {}));
  return <div>{data.name}</div>;
}

// Right
function Parent() {
  return (
    <Suspense fallback={<Skeleton />}>
      <Component />
    </Suspense>
  );
}
```

## Performance Metrics

After implementing this pattern, you should see:

- **Initial Navigation**: 50-90% faster (cached data renders immediately)
- **Subsequent Navigations**: Near-instant (data preloaded on hover)
- **Time to Interactive**: Improved (shell renders before data)
- **Perceived Performance**: Significantly better (progressive loading)

## Do You Need SWR or Additional Libraries?

**No!** You already have everything you need:

- ‚úÖ Stale-while-revalidate: TanStack Query provides this
- ‚úÖ Caching: Built into your ConvexQueryClient setup
- ‚úÖ Preloading: Router configured with `defaultPreload: "intent"`
- ‚úÖ Reactivity: Convex pushes updates automatically
- ‚úÖ Deduplication: TanStack Query handles this

The combination of **Convex + TanStack Query + TanStack Router** is more powerful than SWR alone because:

1. **Real-time updates** (Convex pushes changes)
2. **Automatic preloading** (router integration)
3. **Progressive rendering** (Suspense)
4. **Type-safe** (end-to-end from DB to UI)

---

_Last updated: 2025-11-10 - Initial guide for optimizing navigation performance with existing ConvexQueryClient setup_
