<!-- 60946961-0338-4c74-964b-1a1b2e53d760 26eee5d1-568d-4875-b6af-b6fbc1b376b5 -->
# AI-Enhanced Transaction Matching (Updated with Official SDKs)

## System Architecture

The AI enrichment system activates automatically when a transaction scores 70-89 points (low confidence). It gathers contextual data from multiple sources using official SDKs (Firecrawl Node SDK, Google Places API New, OpenAI Node SDK), uses GPT-4 to reason about the match, and provides both an immediate decision and learning insights for future matches.

## Implementation Steps

### 1. Schema Updates (convex/schema.ts)

Add enrichment cache table to store gathered business metadata:

```typescript
businessEnrichment: defineTable({
  businessId: v.id("businesses"),
  source: v.string(), // "google_places", "firecrawl", "manual"
  data: v.object({
    priceRange: v.optional(v.string()), // "$", "$$", "$$$", "$$$$"
    popularItems: v.optional(v.array(v.string())),
    averageTransactionAmount: v.optional(v.number()),
    peakHours: v.optional(v.array(v.string())),
    paymentMethods: v.optional(v.array(v.string())),
    websiteUrl: v.optional(v.string()),
    photos: v.optional(v.array(v.string())),
    rating: v.optional(v.number()),
    reviewCount: v.optional(v.number()),
  }),
  enrichedAt: v.number(),
  expiresAt: v.number(), // Cache for 30 days
})
  .index("by_businessId", ["businessId"])
  .index("by_expiresAt", ["expiresAt"])

// Add field to track AI match decisions for learning
aiMatchDecisions: defineTable({
  transactionId: v.id("transactions"),
  businessId: v.id("businesses"),
  manualScore: v.number(), // Original 70-89 score
  aiScore: v.number(), // AI confidence 0-100
  reasoning: v.string(), // GPT-4 explanation
  decision: v.union(v.literal("match"), v.literal("skip"), v.literal("uncertain")),
  signals: v.array(v.string()), // Which signals contributed
  createdAt: v.number(),
})
  .index("by_transactionId", ["transactionId"])
  .index("by_decision", ["decision"])
```

### 2. Environment Variables

Add to `.env.local` and Convex dashboard:

```bash
# Google Places API (cheaper, good for basic info)
GOOGLE_PLACES_API_KEY=your_key_here

# Firecrawl API (website scraping, $1 per 1000 pages)
FIRECRAWL_API_KEY=your_key_here

# OpenAI API (GPT-4 for reasoning)
OPENAI_API_KEY=your_key_here

# Rate limiting configs
AI_ENRICHMENT_DAILY_LIMIT=100 # Start conservative
AI_ENRICHMENT_CACHE_DAYS=30
```

### 3. Create Enrichment Module (convex/matching/enrichment.ts)

```typescript
"use node";
import { internalAction, internalMutation, internalQuery } from "../_generated/server";
import { internal } from "../_generated/api";
import { v } from "convex/values";

// Google Places API client
async function getGooglePlacesData(businessName: string, location?: { lat: number; lng: number }) {
  const apiKey = process.env.GOOGLE_PLACES_API_KEY!;
  
  const query = location 
    ? `${businessName} near ${location.lat},${location.lng}`
    : businessName;
  
  const response = await fetch(
    `https://maps.googleapis.com/maps/api/place/findplacefromtext/json?input=${encodeURIComponent(query)}&inputtype=textquery&fields=place_id,name,rating,user_ratings_total,price_level,opening_hours,photos&key=${apiKey}`
  );
  
  const data = await response.json();
  if (!data.candidates?.[0]) return null;
  
  const placeId = data.candidates[0].place_id;
  
  // Get detailed info
  const detailsResponse = await fetch(
    `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=name,rating,user_ratings_total,price_level,website,photos,editorial_summary&key=${apiKey}`
  );
  
  const details = await detailsResponse.json();
  return details.result;
}

// Firecrawl for website scraping
async function scrapeBusinessWebsite(websiteUrl: string) {
  const apiKey = process.env.FIRECRAWL_API_KEY!;
  
  const response = await fetch("https://api.firecrawl.dev/v1/scrape", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      url: websiteUrl,
      formats: ["markdown"],
      onlyMainContent: true,
    }),
  });
  
  const data = await response.json();
  return data.markdown;
}

// Main enrichment action
export const enrichBusinessForMatch = internalAction({
  args: {
    businessId: v.id("businesses"),
    transactionId: v.id("transactions"),
    currentScore: v.number(),
  },
  returns: v.object({
    shouldMatch: v.boolean(),
    aiConfidence: v.number(),
    reasoning: v.string(),
  }),
  handler: async (ctx, args) => {
    // 1. Check cache first
    const cachedData = await ctx.runQuery(
      internal.matching.enrichment.getCachedEnrichment,
      { businessId: args.businessId }
    );
    
    // 2. Get business and transaction details
    const business = await ctx.runQuery(
      internal.matching.enrichment.getBusinessDetails,
      { businessId: args.businessId }
    );
    
    const transaction = await ctx.runQuery(
      internal.matching.enrichment.getTransactionDetails,
      { transactionId: args.transactionId }
    );
    
    // 3. Gather enrichment data if cache expired or missing
    let enrichmentData = cachedData?.data;
    
    if (!cachedData || cachedData.expiresAt < Date.now()) {
      // Start with Google Places (cheaper)
      const placesData = await getGooglePlacesData(
        business.name,
        business.location
      );
      
      enrichmentData = {
        priceRange: placesData?.price_level 
          ? "$".repeat(placesData.price_level) 
          : undefined,
        rating: placesData?.rating,
        reviewCount: placesData?.user_ratings_total,
        websiteUrl: placesData?.website,
      };
      
      // Only use Firecrawl if we have a website and need more context
      if (placesData?.website && args.currentScore < 75) {
        const websiteContent = await scrapeBusinessWebsite(placesData.website);
        
        // Extract menu items, pricing from website content
        enrichmentData.popularItems = extractMenuItems(websiteContent);
        enrichmentData.paymentMethods = extractPaymentMethods(websiteContent);
      }
      
      // Cache the enrichment data
      await ctx.runMutation(
        internal.matching.enrichment.cacheEnrichmentData,
        {
          businessId: args.businessId,
          data: enrichmentData,
          ttlDays: parseInt(process.env.AI_ENRICHMENT_CACHE_DAYS || "30"),
        }
      );
    }
    
    // 4. Use GPT-4 to analyze and make decision
    const aiDecision = await analyzeWithGPT4({
      transaction,
      business,
      enrichmentData,
      currentScore: args.currentScore,
    });
    
    // 5. Store AI decision for learning
    await ctx.runMutation(
      internal.matching.enrichment.recordAiDecision,
      {
        transactionId: args.transactionId,
        businessId: args.businessId,
        manualScore: args.currentScore,
        aiScore: aiDecision.confidence,
        reasoning: aiDecision.reasoning,
        decision: aiDecision.shouldMatch ? "match" : "skip",
        signals: aiDecision.contributingSignals,
      }
    );
    
    return {
      shouldMatch: aiDecision.shouldMatch,
      aiConfidence: aiDecision.confidence,
      reasoning: aiDecision.reasoning,
    };
  },
});

// GPT-4 analysis
async function analyzeWithGPT4(context: any) {
  const apiKey = process.env.OPENAI_API_KEY!;
  
  const prompt = `You are a transaction matching expert. Analyze if this transaction belongs to this business.

TRANSACTION:
- Merchant Name: ${context.transaction.merchantName}
- Amount: $${(context.transaction.amount / 100).toFixed(2)}
- Time: ${context.transaction.date}
- Category: ${context.transaction.category?.join(", ") || "Unknown"}

BUSINESS:
- Name: ${context.business.name}
- Category: ${context.business.category}
- Statement Descriptors: ${context.business.statementDescriptors?.join(", ") || "None"}
- Price Range: ${context.enrichmentData?.priceRange || "Unknown"}
- Average Rating: ${context.enrichmentData?.rating || "Unknown"}
- Popular Items: ${context.enrichmentData?.popularItems?.join(", ") || "Unknown"}

CURRENT MATCH SCORE: ${context.currentScore}/100 (low confidence)

Analyze:
1. Does the transaction amount match the business's price range?
2. Do the categories align?
3. Are there any red flags (e.g., completely different business types)?
4. What additional signals support or contradict this match?

Respond in JSON:
{
  "shouldMatch": boolean,
  "confidence": number (0-100),
  "reasoning": "brief explanation",
  "contributingSignals": ["signal1", "signal2"]
}`;

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: "gpt-4o-mini", // Start with mini for cost savings
      messages: [
        { role: "system", content: "You are a precise transaction matching analyst. Return only valid JSON." },
        { role: "user", content: prompt }
      ],
      response_format: { type: "json_object" },
      temperature: 0.1, // Low temperature for consistent decisions
    }),
  });
  
  const data = await response.json();
  return JSON.parse(data.choices[0].message.content);
}

// Helper functions
function extractMenuItems(markdown: string): string[] {
  // Simple regex to find prices and items before them
  const items: string[] = [];
  const pricePattern = /(.{3,30})\s*\$(\d+(?:\.\d{2})?)/g;
  let match;
  
  while ((match = pricePattern.exec(markdown)) !== null && items.length < 10) {
    items.push(match[1].trim());
  }
  
  return items;
}

function extractPaymentMethods(markdown: string): string[] {
  const methods: string[] = [];
  const patterns = [
    /square/i,
    /stripe/i,
    /paypal/i,
    /venmo/i,
    /apple pay/i,
    /google pay/i,
  ];
  
  for (const pattern of patterns) {
    if (pattern.test(markdown)) {
      methods.push(pattern.source.replace(/[\/\\^$*+?.()|[\]{}]/g, ''));
    }
  }
  
  return methods;
}
```

### 4. Update matchTransaction.ts

Modify the matching function to call enrichment for low-confidence matches:

```typescript
// In matchTransaction.ts, after line 161 (where CONFIDENCE_THRESHOLD is checked)

if (bestMatch && bestMatch.score >= CONFIDENCE_THRESHOLD) {
  // ... existing auto-match logic
}
// NEW: AI enrichment for low-confidence matches
else if (bestMatch && bestMatch.score >= 70 && bestMatch.score < CONFIDENCE_THRESHOLD) {
  console.log(
    `ðŸ¤– Low-confidence match (${bestMatch.score}), triggering AI enrichment for tx ${tx.plaidTransactionId}`
  );
  
  // Schedule AI enrichment (async, doesn't block)
  await ctx.scheduler.runAfter(
    0,
    internal.matching.enrichment.enrichBusinessForMatch,
    {
      businessId: bestMatch.business._id,
      transactionId: args.transactionId,
      currentScore: bestMatch.score,
    }
  );
  
  // Transaction remains unmatched for now - AI will decide asynchronously
  return null;
}
```

### 5. Create AI Decision Handler (convex/matching/applyAiDecision.ts)

```typescript
import { internalMutation } from "../_generated/server";
import { internal } from "../_generated/api";
import { v } from "convex/values";

export const applyAiMatchDecision = internalMutation({
  args: {
    transactionId: v.id("transactions"),
    businessId: v.id("businesses"),
    shouldMatch: v.boolean(),
    aiConfidence: v.number(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    if (!args.shouldMatch) {
      console.log(
        `ðŸ¤– AI decided NOT to match tx ${args.transactionId} (confidence: ${args.aiConfidence})`
      );
      return null;
    }
    
    // AI approved the match - update transaction
    await ctx.db.patch(args.transactionId, {
      businessId: args.businessId,
      status: "matched",
    });
    
    console.log(
      `ðŸ¤– AI matched tx ${args.transactionId} to business ${args.businessId} (confidence: ${args.aiConfidence})`
    );
    
    // Calculate rewards
    const tx = await ctx.db.get(args.transactionId);
    if (tx) {
      await ctx.runMutation(internal.matching.calculateRewards.calculateRewards, {
        userId: tx.userId,
        businessId: args.businessId,
        transactionId: args.transactionId,
      });
    }
    
    return null;
  },
});
```

### 6. Helper Queries and Mutations (convex/matching/enrichment.ts continued)

```typescript
export const getCachedEnrichment = internalQuery({
  args: { businessId: v.id("businesses") },
  returns: v.union(v.null(), v.object({
    data: v.any(),
    expiresAt: v.number(),
  })),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("businessEnrichment")
      .withIndex("by_businessId", (q) => q.eq("businessId", args.businessId))
      .filter((q) => q.gt(q.field("expiresAt"), Date.now()))
      .first();
  },
});

export const cacheEnrichmentData = internalMutation({
  args: {
    businessId: v.id("businesses"),
    data: v.any(),
    ttlDays: v.number(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const expiresAt = Date.now() + args.ttlDays * 24 * 60 * 60 * 1000;
    
    await ctx.db.insert("businessEnrichment", {
      businessId: args.businessId,
      source: "ai_enrichment",
      data: args.data,
      enrichedAt: Date.now(),
      expiresAt,
    });
    
    return null;
  },
});

export const getBusinessDetails = internalQuery({
  args: { businessId: v.id("businesses") },
  returns: v.any(),
  handler: async (ctx, args) => {
    return await ctx.db.get(args.businessId);
  },
});

export const getTransactionDetails = internalQuery({
  args: { transactionId: v.id("transactions") },
  returns: v.any(),
  handler: async (ctx, args) => {
    return await ctx.db.get(args.transactionId);
  },
});

export const recordAiDecision = internalMutation({
  args: {
    transactionId: v.id("transactions"),
    businessId: v.id("businesses"),
    manualScore: v.number(),
    aiScore: v.number(),
    reasoning: v.string(),
    decision: v.string(),
    signals: v.array(v.string()),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("aiMatchDecisions", {
      transactionId: args.transactionId,
      businessId: args.businessId,
      manualScore: args.manualScore,
      aiScore: args.aiScore,
      reasoning: args.reasoning,
      decision: args.decision as any,
      signals: args.signals,
      createdAt: Date.now(),
    });
    
    return null;
  },
});
```

### 7. Package Dependencies

Add to package.json:

```json
{
  "dependencies": {
    "@google/maps": "^1.1.3", // For Google Places API types
    "openai": "^4.80.1" // Official OpenAI SDK
  }
}
```

### 8. Rate Limiting (convex/matching/rateLimiter.ts)

Prevent API cost overruns:

```typescript
import { internalMutation, internalQuery } from "../_generated/server";
import { v } from "convex/values";

export const checkRateLimit = internalQuery({
  args: {},
  returns: v.boolean(),
  handler: async (ctx) => {
    const today = new Date().toISOString().split("T")[0];
    const dailyLimit = parseInt(process.env.AI_ENRICHMENT_DAILY_LIMIT || "100");
    
    const count = await ctx.db
      .query("aiMatchDecisions")
      .filter((q) => {
        const createdDate = new Date(q.field("createdAt")).toISOString().split("T")[0];
        return createdDate === today;
      })
      .collect();
    
    return count.length < dailyLimit;
  },
});
```

## Cost Optimization Strategy

1. **Tiered API Usage:**

   - Always use Google Places first (cheaper)
   - Only use Firecrawl for scores 70-74 (highest uncertainty)
   - Cache all enrichment data for 30 days

2. **Rate Limiting:**

   - Start with 100 AI enrichments per day
   - Monitor costs and adjust based on accuracy improvements
   - Prioritize high-value transactions (larger amounts)

3. **Smart Caching:**

   - Cache enrichment data per business (not per transaction)
   - 30-day TTL reduces repeated API calls
   - Cron job to clean expired cache entries

## Learning and Improvement

The system stores all AI decisions with reasoning. Future enhancements:

- Analyze which signals most often lead to correct matches
- Adjust scoring weights based on AI feedback
- Build a training dataset for custom ML model (reduce OpenAI costs)

## Monitoring

Track these metrics in a dashboard:

- AI enrichment usage (daily count)
- Match accuracy rate (AI matches that remain valid)
- Cost per enrichment
- Cache hit rate
- Average confidence scores

## Files to Create/Modify

1. `convex/schema.ts` - Add enrichment tables
2. `convex/matching/enrichment.ts` - Main enrichment logic
3. `convex/matching/applyAiDecision.ts` - Apply AI decisions
4. `convex/matching/rateLimiter.ts` - Cost controls
5. `convex/matching/matchTransaction.ts` - Trigger enrichment
6. `package.json` - Add dependencies
7. `.env.local` - Add API keys